%--------------------------------------------------------------------------
% # Test case 3: Matrix inversion
%
% We would like to approximate 1/x over [1/kappa,1] by a polynomial, such 
% polynomial is generated by Remez algorithm and the approximation error is
% bounded by 10^{-14}
%
% parameters
%     kappa: parameters of approximation
%     parity: parity of approximation polynomial (0 -- even, 1 -- odd)
%     criteria: stop criteria, default 1e-12
%     plot_phase: whether plot phase factors
%
% note that coefficients corresponds to parameter kappa are pre-calculated,
% one can only choose kappa = 10,20,30,40,50
%
%--------------------------------------------------------------------------
%
% Reference: Yulong Dong, Xiang  Meng, K.Birgitta Whaley and Lin Lin
%            Efficient Phase Factor Evaluation in Quantum Signal Processing
%
% Author: Yulong Dong, Xiang Meng
% Version 1.0
% Last Update 06/2020
%
%--------------------------------------------------------------------------
% setup parameters

kappa = 50;
parity = 1;
criteria = 1e-12;
plot_phase = true;

%--------------------------------------------------------------------------
% find phase factors

opts.criteria = criteria;
if(parity==0)
    load("coef_xeven_"+int2str(kappa)+"_"+int2str(14)+".mat","coef");
else
    load("coef_xodd_"+int2str(kappa)+"_"+int2str(14)+".mat","coef");
end
coef = coef/2; % the L^\infty norm of original polynomial is greater than 1
if(parity==0)
    maxorder = length(coef)*2-2;
else
    maxorder = length(coef)*2-1;
end
[phi,out] = QSP_solver(coef,parity,opts);
parity_label = ["even" "odd"];
fprintf("- Info: \t\tQSP phase factors --- solved by L-BFGS\n")
fprintf("- Parity: \t\t%s\n- Degree: \t\t%d\n", parity_label(parity+1), maxorder);
fprintf("- Iteration times: \t%d\n", out.iter);
fprintf("- CPU time: \t%.1f s\n", out.time);

%--------------------------------------------------------------------------
% plot phase factors

if(plot_phase)
    figure(1);
    temp = phi;
    temp(1) = temp(1) - pi/4;
    temp(end) = temp(end) - pi/4;
    plot(1:length(temp),temp);
    
    x = linspace(1/kappa,1,1000);
    y = 1./x;
    yqsp = zeros(size(x));
    for jj = 1:length(x)
        yqsp(jj) = QSPGetUnitary(phi, x(jj));
    end
    scale_fac = mean(rmmissing(yqsp./y));
    fprintf("- Linf approximation error: \t%.2e\n", norm(y*scale_fac - yqsp, inf));
end

%--------------------------------------------------------------------------
